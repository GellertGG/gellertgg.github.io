<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>
        Hexo
    </title>
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-reply replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            jvm字节码
        </p>
        <hr>
    </div>
    <div class="post-content">
        <p>[toc]</p>
<h4 id="class文件结构"><a href="#class文件结构" class="headerlink" title="class文件结构"></a>class文件结构</h4><p>一个类文件的结构基本如下图所示：</p>
<img src="/Users/kerry/Desktop/jvm相关/classfile.png" alt="classfile" style="zoom:33%;" />

<ol>
<li>魔数<ul>
<li>魔数就是CAFEBABE class文件的标志头</li>
</ul>
</li>
<li>class文件主版本号和次版本号</li>
<li>常量池计数器</li>
<li>常量池<ul>
<li>class文件的资源仓库</li>
<li>字面量(文本字符串，声明为final的常量)</li>
<li>符号引用(类和接口的全限定名，字段的名称和描述符、方法的名称和描述符)</li>
<li>符号引用和直接引用的关系</li>
<li>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可</li>
<li>直接引用和虚拟机的布局是相关的，不同的虚拟机对于相同的符号引用所翻译出来的直接引用一般是不同的。如果有了直接引用，那么直接引用的目标一定被加载到了内存中。</li>
</ul>
</li>
<li>访问标志<ul>
<li>跟在常量池后面，用来标识一个类是是不是final、abstract、public、注解类、枚举类等</li>
</ul>
</li>
<li>类索引、父类索引<ul>
<li>用来确定类的继承关系</li>
</ul>
</li>
<li>接口计数器和接口索引集合</li>
<li>字段计数器和字段表集合<ul>
<li>类中定义的字段会被存储到这个集合中，包括类中定义的静态和非静态的字段，不包括方法内部定义的变量。</li>
<li>每个字段都有字段属性计数器和字段属性表集合<ul>
<li>主要包括ConstantValue、Signature等</li>
</ul>
</li>
</ul>
</li>
<li>方法计数器和方法表集合<ul>
<li>类中定义的方法会被存储在这里</li>
<li>每个字段都有方法属性计数器和方法属性表集合<ul>
<li>主要包括Code、Exceptions、MethodParameters、Signature、LineNumberTable等</li>
</ul>
</li>
</ul>
</li>
<li>class文件属性表计数器和class文件属性表集合<ul>
<li>主要包括SourceFile、InnerClasses、EnclosingMethod等</li>
</ul>
</li>
</ol>
<h4 id="jvm字节码指令"><a href="#jvm字节码指令" class="headerlink" title="jvm字节码指令"></a>jvm字节码指令</h4><ol>
<li><p>加载和存储指令</p>
<p>用于将数据在栈帧中的局部变量表和操作数栈之间来回传输，主要有：</p>
<ul>
<li>将一个局部变量加载到操作数栈中：<code>iload、iload_&lt;n&gt;、lload、lload_&lt;n&gt;、fload、fload_&lt;n&gt;、dload、dload_&lt;n&gt;、aload、aload_&lt;n&gt;</code></li>
<li>将一个数值从操作数栈存储到局部变量表：<code>istore、istore_&lt;n&gt;、lstore、lstore_&lt;n&gt;、fstore、fstore_&lt;n&gt;、dstore、dstore_&lt;n&gt;、astore、astore_&lt;n&gt;</code></li>
<li>将一个常量加载到操作数栈：<code>bipush、sipush、ldc、ldc_w、aconst_null、iconst_m1、iconst_&lt;i&gt;、lconst_&lt;l&gt;、fconst_&lt;f&gt;、dconst_&lt;d&gt;</code></li>
</ul>
</li>
<li><p>运算指令</p>
<ul>
<li>加法指令iadd、减法指令、乘法指令、除法指令、求余指令、取反指令、位移指令、按位或指令、按位与指令、按位异或指令、局部变量自增指令iinc、比较指令</li>
</ul>
</li>
<li><p>类型转换指令（针对数值类型）</p>
<ul>
<li>窄化类型转换，如：i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2f和d2l</li>
</ul>
</li>
<li><p>对象创建和访问指令</p>
<ul>
<li>创建类实例指令：new</li>
<li>创建数组指令：newarray、anewarray、multianewarray</li>
<li>访问类字段和类变量：getfield、putfield、getstatic、putstatic</li>
<li>将数组元素加载到操作数栈：baload、caload、saload、iadload、laload、faload、daload、aaload</li>
<li>将一个操作数栈的值存储到数组元素中：bastore、castore、sastore、iastore、fastore、dastore、aastore</li>
<li>取数组长度指令：arraylength</li>
<li>检查类实例类型的指令：instanceof、checkcast</li>
</ul>
</li>
<li><p>操作数栈管理指令(用于直接操作操作数栈)</p>
<ul>
<li>栈顶一个或者两个元素出栈：pop、pop2</li>
<li>复制栈顶一个或两个数值并将复制值或双份的复制重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2</li>
<li>将栈最顶端的两个数值互换：swap</li>
</ul>
</li>
<li><p>控制转移指令(可以认为是直接修改PC寄存器的值，用来执行指定位置的指令)</p>
<ul>
<li>条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull等</li>
<li>复合条件分支：tableswitch、lookupswitch</li>
<li>无条件分支：goto、goto_w、jsr、jsr_w、ret</li>
</ul>
</li>
<li><p>方法调用和返回指令</p>
<ul>
<li>invokevirtual：调用实例方法，(public、protect等)根据实例的类型进行分派</li>
<li>invokeinterface：调用接口方法，会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用</li>
<li>invokespecial：调用实例方法，专门用来调用父类方法、私有方法和实例初始化方法，也就是那些类加载时就能确定需要调用的具体方法，而不需要等到运行时去根据实际的对象值去调用该对象的方法</li>
<li>invokestatic：调用类(静态)方法</li>
<li>invokedynamic：调用动态方法，在运行时动态解析出调用点限定符所引用的方法，并执行该方法(没大理解)</li>
</ul>
</li>
<li><p>异常处理指令</p>
<ul>
<li>java中显示抛出异常的操作都是由athrow指令完成</li>
</ul>
</li>
<li><p>同步指令</p>
<ul>
<li>monitorenter指令</li>
<li>monitorexit指令</li>
</ul>
</li>
</ol>
<h4 id="从字节码看栈的解释器执行过程"><a href="#从字节码看栈的解释器执行过程" class="headerlink" title="从字节码看栈的解释器执行过程"></a>从字节码看栈的解释器执行过程</h4><p>java方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> c = a + b;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>通过javap -c查看编译后的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void testAdd(int, int);</span><br><span class="line">  Code:</span><br><span class="line">     0: iload_1 &#x2F;&#x2F; 将局部变量1加载到操作数栈中</span><br><span class="line">     1: iload_2 &#x2F;&#x2F; 将局部变量2加载到操作数栈中</span><br><span class="line">     2: iadd &#x2F;&#x2F;将栈顶两个int型数值相加并将结果压入栈顶</span><br><span class="line">     3: istore_3 &#x2F;&#x2F;将栈顶int型数值存入到第四个本地变量</span><br><span class="line">     4: return &#x2F;&#x2F;返回void</span><br></pre></td></tr></table></figure>

<h4 id="从字节码看自增"><a href="#从字节码看自增" class="headerlink" title="从字节码看自增"></a>从字节码看自增</h4><p>java方法源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testIAdd</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">      i = ++i + i++ + i++ + i++;</span><br><span class="line">      System.out.println(<span class="string">"i="</span> + i);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>通过javap -c查看编译后的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> 0 iconst_0      &#x2F;&#x2F;将int型0推送到栈顶</span><br><span class="line"> 1 istore_0      &#x2F;&#x2F;将栈顶int型数值存储到第一个本地变量中</span><br><span class="line"> 2 iinc 0 by 1   &#x2F;&#x2F;自增，第一个本地变量的i为1</span><br><span class="line"> 5 iload_0       &#x2F;&#x2F;将第一个int型本地变量i&#x3D;1加载到栈顶</span><br><span class="line"> 6 iload_0       &#x2F;&#x2F;将第一个int型本地变量i&#x3D;1加载到栈顶</span><br><span class="line"> 7 iinc 0 by 1   &#x2F;&#x2F;自增，第一个本地变量的i为2</span><br><span class="line">10 iadd          &#x2F;&#x2F;将栈顶两个int型数值相加并将结果压入栈顶，栈顶为2</span><br><span class="line">11 iload_0       &#x2F;&#x2F;将第一个int型本地变量i&#x3D;2加载到栈顶</span><br><span class="line">12 iinc 0 by 1   &#x2F;&#x2F;自增，第一个本地变量的i为3</span><br><span class="line">15 iadd          &#x2F;&#x2F;将栈顶两个int型数值相加并将结果压入栈顶，栈顶为4</span><br><span class="line">16 iload_0       &#x2F;&#x2F;将第一个int型本地变量i&#x3D;3加载到栈顶</span><br><span class="line">17 iinc 0 by 1   &#x2F;&#x2F;自增，第一个本地变量的i为4</span><br><span class="line">20 iadd					 &#x2F;&#x2F;将栈顶两个int型数值相加并将结果压入栈顶，栈顶为7</span><br><span class="line">21 istore_0      &#x2F;&#x2F;将栈顶int型数值7存入到第一个本地变量</span><br><span class="line">22 getstatic #2 &lt;java&#x2F;lang&#x2F;System.out&gt;</span><br><span class="line">25 new #3 &lt;java&#x2F;lang&#x2F;StringBuilder&gt;</span><br><span class="line">28 dup</span><br><span class="line">29 invokespecial #4 &lt;java&#x2F;lang&#x2F;StringBuilder.&lt;init&gt;&gt;</span><br><span class="line">32 ldc #5 &lt;i&#x3D;&gt;</span><br><span class="line">34 invokevirtual #6 &lt;java&#x2F;lang&#x2F;StringBuilder.append&gt;</span><br><span class="line">37 iload_0        &#x2F;&#x2F;将第一个int型本地变量i&#x3D;7加载到栈顶</span><br><span class="line">38 invokevirtual #7 &lt;java&#x2F;lang&#x2F;StringBuilder.append&gt;</span><br><span class="line">41 invokevirtual #8 &lt;java&#x2F;lang&#x2F;StringBuilder.toString&gt;</span><br><span class="line">44 invokevirtual #9 &lt;java&#x2F;io&#x2F;PrintStream.println&gt;</span><br><span class="line">47 return</span><br></pre></td></tr></table></figure>

<p>基于栈的解释执行来进行动图演示如下：</p>
<img src="/Users/kerry/Desktop/jvm相关/2019-11-25 11-58-12.2019-11-25 12_01_29.gif" alt="2019-11-25 11-58-12.2019-11-25 12_01_29" style="zoom:70%;" />

<h4 id="从字节码看switch"><a href="#从字节码看switch" class="headerlink" title="从字节码看switch"></a>从字节码看switch</h4><blockquote>
<p>编译器会使用tableswitch和lookupswitch指令来生成switch语句的编译代码。tableswitch指令用于表示switch结构中的case语句块，它可以高效的从索引表中确定case语句块的分支偏移量。当switch语句中的条件值不能对应于索引表中任何一个case语句块的分支偏移量，default分支将起作用。</p>
</blockquote>
<p>java方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">chooseNear</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过javap -verbose查看编译后的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0: iload_1                           &#x2F;&#x2F;从局部变量表加载第一个本地变量到栈上</span><br><span class="line">  1: tableswitch   &#123; &#x2F;&#x2F; 0 to 2         &#x2F;&#x2F;根据索引值在跳转表中寻找配对的分支进行跳转（索引范围0-2）</span><br><span class="line">                0: 28									&#x2F;&#x2F;是0则跳到28</span><br><span class="line">                1: 30                  &#x2F;&#x2F;是1则跳到30</span><br><span class="line">                2: 32                  &#x2F;&#x2F;是2则跳到32</span><br><span class="line">          default: 34                  &#x2F;&#x2F;其他情况跳到34</span><br><span class="line">     &#125;</span><br><span class="line"> 28: iconst_0                          &#x2F;&#x2F;将0入栈到操作数栈上</span><br><span class="line"> 29: ireturn														&#x2F;&#x2F;将栈顶元素出栈并返回</span><br><span class="line"> 30: iconst_1													&#x2F;&#x2F;将1入栈到操作数栈上</span><br><span class="line"> 31: ireturn														&#x2F;&#x2F;将栈顶元素出栈并返回</span><br><span class="line"> 32: iconst_2													&#x2F;&#x2F;将2入栈到操作数栈上</span><br><span class="line"> 33: ireturn														&#x2F;&#x2F;将栈顶元素出栈并返回</span><br><span class="line"> 34: iconst_m1													&#x2F;&#x2F;将-1入栈到操作数栈上</span><br><span class="line"> 35: ireturn														&#x2F;&#x2F;将栈顶元素出栈并返回</span><br></pre></td></tr></table></figure>

<h6 id="tableswitch"><a href="#tableswitch" class="headerlink" title="tableswitch"></a>tableswitch</h6><p>看下这个例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">chooseNear</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:  <span class="comment">//这边变成了4</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候再看字节码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> 1: tableswitch   &#123; &#x2F;&#x2F; 0 to 4     &#x2F;&#x2F;这边多了2和3的索引</span><br><span class="line">               0: 36</span><br><span class="line">               1: 38</span><br><span class="line">               2: 42      </span><br><span class="line">               3: 42</span><br><span class="line">               4: 40</span><br><span class="line">         default: 42</span><br><span class="line">    &#125;</span><br><span class="line">36: iconst_0</span><br><span class="line">37: ireturn</span><br><span class="line">38: iconst_1</span><br><span class="line">39: ireturn</span><br><span class="line">40: iconst_2</span><br><span class="line">41: ireturn</span><br><span class="line">42: iconst_m1</span><br><span class="line">43: ireturn</span><br></pre></td></tr></table></figure>

<p>可以看到索引范围里面多了2和3，这是因为采用 tableswitch 来实现 switch-case，有断层的会<strong>生成一些虚假的 case 帮忙补齐连续</strong>，这样可以实现 O(1) 时间复杂度的查找</p>
<h6 id="lookupswitch"><a href="#lookupswitch" class="headerlink" title="lookupswitch"></a>lookupswitch</h6><p>上面只是少量的断层情况，如果断层过大、过多会发生什么呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">chooseNear</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 0: iload_1</span><br><span class="line"> 1: lookupswitch  &#123; &#x2F;&#x2F; 3</span><br><span class="line">               0: 36</span><br><span class="line">              10: 38</span><br><span class="line">             100: 40</span><br><span class="line">         default: 42</span><br><span class="line">    &#125;</span><br><span class="line">36: iconst_0</span><br><span class="line">37: ireturn</span><br><span class="line">38: iconst_1</span><br><span class="line">39: ireturn</span><br><span class="line">40: iconst_2</span><br><span class="line">41: ireturn</span><br><span class="line">42: iconst_m1</span><br><span class="line">43: ireturn</span><br></pre></td></tr></table></figure>

<p>可以看到，字节码里面不再是tableswitch而是使用lookupswitch指令，如果依旧是使用tableswitch指令的话，虽然会提升索引查询速度，但是class文件大小会变得很大。lookupswitch指令之后的所有匹配键值对，都必须按照升序存储，便于更快的搜索(使用二分法等)</p>
<p>java虚拟机的tableswitch和lookupswitch都只能支持int类型的条件值，如果是其他类型都会转成int类型，对于String和引用类型，则会使用其hashcode值当做条件值</p>
<h4 id="从字节码看泛型"><a href="#从字节码看泛型" class="headerlink" title="从字节码看泛型"></a>从字节码看泛型</h4><p>我们知道java中泛型是通过擦除法实现的伪泛型，泛型信息在编译成字节码后的泛型信息会被擦除</p>
<p>但是泛型在编译后完全被擦除么？</p>
<p>java方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGeneric</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过javap -verbose查看编译后结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void testGeneric(java.util.List&lt;java.lang.String&gt;);</span><br><span class="line">   descriptor: (Ljava&#x2F;util&#x2F;List;)V</span><br><span class="line">   flags: ACC_PUBLIC</span><br><span class="line">   Code:</span><br><span class="line">     stack&#x3D;0, locals&#x3D;2, args_size&#x3D;2</span><br><span class="line">        0: return</span><br><span class="line">     LineNumberTable:</span><br><span class="line">       line 21: 0</span><br><span class="line">     LocalVariableTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           0       1     0  this   Lcom&#x2F;kerry&#x2F;springstudy&#x2F;jvmtemp&#x2F;SynchronizedTest;</span><br><span class="line">           0       1     1  list   Ljava&#x2F;util&#x2F;List;</span><br><span class="line">     LocalVariableTypeTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           0       1     1  list   Ljava&#x2F;util&#x2F;List&lt;Ljava&#x2F;lang&#x2F;String;&gt;;</span><br><span class="line">   Signature: #22                          &#x2F;&#x2F; (Ljava&#x2F;util&#x2F;List&lt;Ljava&#x2F;lang&#x2F;String;&gt;;)V</span><br></pre></td></tr></table></figure>

<p>可以看到在编译后的字节码文件中，方法表的Signature属性记录了泛型的信息，这样就可以通过java的反射api来获取泛型类型，如：<code>class.getGenericSuperclass()</code></p>
<h4 id="从字节码看synchronized"><a href="#从字节码看synchronized" class="headerlink" title="从字节码看synchronized"></a>从字节码看synchronized</h4><h6 id="代码块级"><a href="#代码块级" class="headerlink" title="代码块级"></a>代码块级</h6><p>java方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (SynchronizedTest<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">           System.out.println(<span class="string">"test"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>通过javap -c查看编译后结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> 0: ldc           #2 &#x2F;&#x2F;将常量池中#2符号引用压入栈顶 class com&#x2F;kerry&#x2F;springstudy&#x2F;jvmtemp&#x2F;SynchronizedTest</span><br><span class="line"> 2: dup							 &#x2F;&#x2F;复制栈顶的值插入栈顶</span><br><span class="line"> 3: astore_1				 &#x2F;&#x2F;将栈顶reference类型数据出栈并保存到第一个本地变量中</span><br><span class="line"> 4: monitorenter     &#x2F;&#x2F;栈顶元素出栈，并进入出栈对象的monitor</span><br><span class="line"> 5: getstatic     #3                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line"> 8: ldc           #4                  &#x2F;&#x2F; String test</span><br><span class="line">10: invokevirtual #5                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">13: aload_1          &#x2F;&#x2F;从局部变量表中加载第一个本地变量到栈中</span><br><span class="line">14: monitorexit      &#x2F;&#x2F;栈顶元素出栈，并退出出栈对象的monitor</span><br><span class="line">15: goto          23 &#x2F;&#x2F;方法正常结束，跳转到23返回</span><br><span class="line">18: astore_2         &#x2F;&#x2F;从这步开始是异常路径，将栈顶reference类型数据(异常对象)出栈并保存到第二个本地变量中</span><br><span class="line">19: aload_1					 &#x2F;&#x2F;从局部变量表中加载第一个本地变量到栈中</span><br><span class="line">20: monitorexit      &#x2F;&#x2F;栈顶元素出栈，并退出出栈对象的monitor</span><br><span class="line">21: aload_2          &#x2F;&#x2F;从局部变量表中加载第二个本地变量(异常对象)到栈中</span><br><span class="line">22: athrow           &#x2F;&#x2F;将异常对象重新抛出给方法的调用者</span><br><span class="line">23: return					 &#x2F;&#x2F;方法正常返回</span><br></pre></td></tr></table></figure>

<p>代码块级别的同步是通过monitorenter和monitorexit两个指令实现的，两个指令的相关介绍如下：</p>
<p>代码块级别的同步是通过monitorenter和monitorexit两个指令实现的，两个指令的相关介绍如下：</p>
<p>monitorenter</p>
<blockquote>
<p>任何对象都有一个monitor与之关联。当且仅当一个monitor被持有后，它才会处于锁定状态。线程执行到monitorenter指令时，将会按下列方式尝试获取objectref所对应的monitor的所有权：</p>
<ul>
<li>如果objectref的monitor进入计数器为0，那么线程可以成功进入monitor，以及将计数器值设置为1。当前线程就是monitor的所有者</li>
<li>如果当前线程已经拥有了objectref的monitor，那么它可以重入这个monitor，重入时需将进入计数器的值加1</li>
<li>如果其他线程已经拥有objectref的monitor的所有权，那么当前线程将被阻塞，知道monitor的进入计数器值变为0时，才能重新尝试获取monitor的所有权</li>
</ul>
</blockquote>
<p>monitorexit</p>
<blockquote>
<p>执行monitorexit指令的线程必须是与objectref所引用的实例相对应的monitor的所有者</p>
<p>指令执行时，线程把monitor的进入计数器值减1，如果减1后计数器值为0，那么线程退出monitor，不再是这个monitor的拥有者。其他被这个monitor阻塞的线程可以尝试获取这个monitor的所有权</p>
<p>当objectref为null时，monitorexit指令将抛出NullPointerException异常</p>
<p>否则，如果执行monitorexit的线程原本并没有这个monitor的所有权，那么monitorexit指令将抛出IllegalMonitorStateException异常</p>
</blockquote>
<p>可以看到上述指令中存在两个monitorexit指令，原因是编译器必须确保无论同步代码块中的代码是以何种方式结束（正常返回或者异常退出），代码中调用过的每一个monitorenter必须执行其对应的monitorexit。为了保证这一点，编译器会自动生成一个异常处理器，这个异常处理器的目的就是为了同步代码块抛出异常时能执行 monitorexit。</p>
<h6 id="方法级"><a href="#方法级" class="headerlink" title="方法级"></a>方法级</h6><p>java方法源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"test"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>通过javap -verbose 查看编译后的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void testMethod();</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">  Code:</span><br><span class="line">    stack&#x3D;2, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">       0: getstatic     #2                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">       3: ldc           #3                  &#x2F;&#x2F; String test</span><br><span class="line">       5: invokevirtual #4                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">       8: return</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 14: 0</span><br><span class="line">      line 16: 8</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          0       9     0  this   Lcom&#x2F;kerry&#x2F;springstudy&#x2F;jvmtemp&#x2F;SynchronizedTest;</span><br></pre></td></tr></table></figure>

<p>可以看到flags标志里面有个ACC_SYNCHRONIZED标记，标记介绍如下：</p>
<blockquote>
<p>方法级别的同步是隐式的，作为方法调用的一部分。同步方法的常量池中会有一个ACC_SYNCHRONIZED标志。</p>
<p>当调用一个设置了ACC_SYNCHRONIZED标志的方法，执行线程需要先获得monitor锁，然后开始执行方法，方法执行之后再释放monitor锁，当方法不管是正常return还是抛出异常都会释放对应的monitor锁。</p>
<p>在这期间，如果其他线程来请求执行方法，会因为无法获得监视器锁而被阻断住。如果在方法执行过程中，发生了异常，并且方法内部并没有处理该异常，那么在异常被抛到方法外面之前监视器锁会被自动释放。</p>
</blockquote>
<p>方法级的synchronized是通过ACC_SYNCHRONIZED来实现方法同步的</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>个人觉得可以适当了解下class文件的结构和一些常用指令的用法，这样可以在遇到一些从源代码角度难以理解的代码的执行、输出以及一些代码语法糖时，可以从底层的角度分析理解。同时也可以帮助我们在写代码的时候可以从底层出发思考不同的写法之间会产生什么样的差别，从而选择最佳写法。</p>
<h4 id="手动操作字节码"><a href="#手动操作字节码" class="headerlink" title="手动操作字节码"></a>手动操作字节码</h4><p>主要的几种工具是</p>
<p>ASM：可以直接生产 .class字节码文件，通过ClassReader读取类文件，通过ClassWriter重新构建编译后的类，如修改类名、属性以及方法，也可以生成新的类的字节码文件。</p>
<p>Javassist：强调源代码层次操作字节码的框架Javassist。</p>
<h4 id="实际应用，弄一个插件实现不重启动态调试"><a href="#实际应用，弄一个插件实现不重启动态调试" class="headerlink" title="实际应用，弄一个插件实现不重启动态调试"></a>实际应用，弄一个插件实现不重启动态调试</h4>
    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p>Copyright © 2020 <a class="flink" href="https://hexo.io" target="_blank" rel="noopener">Hexo</a>-<a class="flink" href="https://github.com/sanjinhub/hexo-theme-geek" target="_blank" rel="noopener">Geek</a>.
        <label class="el-switch el-switch-green el-switch-sm" style="vertical-align: sub;">
            <input type="checkbox" name="switch" id="update_style">
            <span class="el-switch-style"></span>
        </label>
<!--         <script type="text/javascript">
        var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
        document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
        </script> -->
    </p>
</div>
<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="CmCti21ooOOIzFOhEyFkFvR0-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="FqiyUqbg7McKN2eG0MCewupf">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>
</body>

</html>